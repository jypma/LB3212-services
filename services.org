#+TITLE: Microservices with Java and Spring Boot
#+PROPERTY: header-args:plantuml :exports results :var _dpi_="150"
#+options: H:3
#+latex_header: \hypersetup{colorlinks=true,linkcolor=blue}
#+LATEX_CLASS_OPTIONS: [8pt]
* Introduction
** Getting started
*** Welcome
[[file:graphics/microservices.png]]
*** This course


[[file:graphics/lb-logo_stort_1363x359.jpg]]

Slides available here:
[[https://github.com/jypma/LB3212-services][https://github.com/jypma/LB3212-services]]

- PDF of slides will be available at completion
- Pull requests with fixes to our typos are welcome :-)

*** About your instructors
- Jan Ypma
  * Java, Scala, Groovy, C++, Rust, Lisp
  * Contributor to various open source projects
  * Fan of functional programming and distributed systems
  * Agile coach
  * =jan@ypmania.net=, https://linkedin.com/in/jypma

- Jakob Bendsen
 * 20+ years of IT and Java experience
 * Teaching at ITU and numerous courses in Danish IT industry
 * Experience with Java/Jakarta EE and Spring (Boot)
 * Likes Kotlin and elegant programs
 * =jakob@logb.dk=, https://linkedin.com/in/jbendsen


*** Schedule, day 1
|  Time | Duration | Activity                                  | Weight |
|-------+----------+-------------------------------------------+--------|
| 09:00 |    00:10 | Welcome, Outline/Agenda                   |        |
| 09:10 |    00:20 | Round table introductions                 |        |
| 09:30 |    00:15 | What's a microservice                     |        |
| 09:45 |    00:15 | The 8 fallacies of distributed computing  |        |
| 10:00 |    00:30 | Design for resilience                     |        |
|-------+----------+-------------------------------------------+--------|
| 10:30 |    00:20 | Break(out) 1                              |        |
|-------+----------+-------------------------------------------+--------|
| 10:50 |    00:20 | Discussion of breakout results            |        |
| 11:10 |    00:60 | Infrastructure architecture               |        |
|-------+----------+-------------------------------------------+--------|
| 12:10 |    00:20 | Break(out) 2                              |        |
| 12:30 |    00:30 | Lunch                                     |        |
|-------+----------+-------------------------------------------+--------|
| 13:00 |    00:20 | Discussion of breakout results            |        |
| 13:20 |    00:40 | Data architecture                         |        |
| 14:00 |    00:40 | Event storming: Events                    |        |
|-------+----------+-------------------------------------------+--------|
| 14:40 |    00:10 | Break                                     |        |
|-------+----------+-------------------------------------------+--------|
| 14:50 |    00:30 | Event storming: Commands and Actors       |        |
| 15:20 |    00:20 | Event storming: Aggregates                |        |
|-------+----------+-------------------------------------------+--------|
| 15:40 |    00:20 | Wrap-up, reserved time for extra subjects |        |
|-------+----------+-------------------------------------------+--------|
#+TBLFM: @3$1..@>$1=@-1$2+@-1$1;U
*** Talk about yourself
- My Background
- What do I hope to get out of the course
- What's the smallest service I've ever written
** What's a microservice
*** Definition
- /Service/
  * One operating system process (often on its own server)
  * Exposes an API (sometimes also a UI)
- /Micro/
  * Theory: It's small
  * Practice: There are many
  * Independently deployable
*** Philosophy
- Business needs evolve
- Team composition changes
- Services should be disposable (design to be replaceable)
  * Rebuilt in 1-3 months
- Per service, use best technology matching experience and requirements
*** Service scope
- Service belongs to one team
  * Team is responsible for entire service software life cycle
- Data store belongs to one service
- Independently deployable
*** Use cases
- Embrace Conway's law: One system belongs to at most one team
- Monoliths are fine to start with
  * Time to market and technical debt vs. holistic design
- Strangler pattern
** The 8 fallacies of distributed computing
*** Which of these is true?

1. The network is reliable.
2. Latency is zero.
3. Bandwidth is infinite.
4. The network is secure.
5. Topology doesn't change.
6. There is one administrator.
7. Transport cost is zero.
8. The network is homogeneous.

*** How well does the following abstraction help?

#+BEGIN_SRC java
MyResponseType callMyRemoteService(String command, byte[] data)
#+END_SRC

* Design for resilience
** Service failure
*** Your (or your colleague's) service will be down
P(everything working) = P(one service is working) ^ n_services

/Our service is up 99% of the time!/

Well, we have about 30 microservices, each with 3 copies.
That means that 63% of the time, at least one service is down somewhere.
** Creating services
*** Guidelines
- Prefer sharded (partitioned) data stores over single points of failure
- Idempotency for all incoming data
- Always deploy more than 1 copy
  * Investigate the need for a cluster-aware distributed framework
- Have a /Service dashboard/ with metrics (more on that later)
- Use =Bulkhead= to protect finite resources
*** Bulkhead
A single resource pool is covering multiple types of application requests

[[file:graphics/svg/without_bulkhead.png]]
*** Bulkhead in place
- Semaphore with an optional timed queue in front
- Other parts of the resource pool are still accessible

[[file:graphics/svg/with_bulkhead.png]]
*** Measure service quality
- Service Level Objective (SLO)
  + Metric that indicates a healthy service to you, e.g.
    * /"The 99th percentile of HTTP response times is at most 300ms"/
    * /"At least 99.9% of HTTP requests result in a successful response"/
  + Typically only internally measured and/or agreed between teams

- Service Level Indicator (SLI)
  + An actual number that indicates the current value of an /SLO/, e.g.
    * 99th percentile response time
    * 24-hour window success rate of HTTP requests

- Service Level Agreement (SLA)
  + Part of a contractual obligation (sometimes legally binding) between parties
    * /"The 95th percentile of HTTP response times is at most 1000ms"/
    * /"At least 99% of HTTP requests result in a successful response"/
  + Typically results in a stricter SLO being applied internally
** Consuming services
*** Guidelines
- Design for failure
  * Have methods/functions reflect doing I/O
  * Make time (and timeouts) explicit
  * Use =Circuit Breaker= where applicable
- Fail fast
  * =System.exit(1)= is a viable error handler
*** Circuit breaker
- Smart state machine towards 1 backend
  * /Closed/: Everything is working normally
  * /Open/: We've determined that the backend is down, and block requests
  * /Half-open/: We're allowing a few requests through, to test the waters

#+BEGIN_SRC plantuml :file graphics/circuit-breaker-state.png :hidden
skinparam dpi _dpi_
hide empty description
[*] --> Closed
Closed : passing requests through

Closed -> Open : [failure rate above threshold]
Open : blocking requests

Open -> Half_Open : [after wait duration]
Half_Open : pass some requests through to test availability

Half_Open -> Closed : [failure rate below threshold]
Half_Open -> Open : [failure rate above threshold]
#+END_SRC

#+RESULTS:
[[file:graphics/circuit-breaker-state.png]]

** Guidelines
*** Microservice pitfalls
- Service co-dependencies
  * Keep HTTP calls one way only
  * Plugin pattern
- Nested synchronous service calls
  * Added latency and failure possibility
  * Avoid these with event sourcing
  * Replicate data instead, or call asynchronously when possible
*** Need more inspiration?
- The twelve-factor app, [[https://12factor.net/][https://12factor.net/]]
- Provides sensible suggestions on a lot of topics
  * Port binding, dev/prod differences, admin processes
- Not the only way (geared towards ruby/python), but worth a thorough read
* Break(out) 1
** Service discovery
*** Introduction
- Break into teams of 2-4 people (20 min)
- Discuss the services and projects you've been a part of (here or at a previous employer), and identify:
  * Examples of a microservice
  * Examples of /definitely NOT/ a microservice

- For each service found, describe how /resilient/ the given service was
  * Usage or absence of /bulkhead/ and/or /circuit breaker/
  * Usage or absence of clustering / replication

*** Discussion
- Describe the services you have found
* Infrastructure architecture
** It's a linux world
*** About linux
[[file:graphics/linux.jpg]]
*** Get familiar with linux
- Micro services are a linux world
- It's easier than ever to get started
  * WSL 2 (some integration, less "linux", and has [[https://www.polv.cc/post/2020/11/wsl-vs-virtualbox][issues]])
  * VirtualBox with e.g. Ubuntu (real linux)
  * Dual boot e.g. Ubuntu
  * Just get a Raspberry Pi

[[file:graphics/tux.png]]
** Partitioned data stores
*** Partitioned data stores: introduction
- All data is split into partitions (also called /shards/), which are copied onto servers
- For each data element, a /key/ determines which partition it's stored on
#+BEGIN_SRC plantuml :file graphics/partitioned-data-stores.png :hidden
skinparam dpi _dpi_
skinparam linetype ortho

node n1 as "Server 1" {
  database b1 as "Partition B"
  database a1 as "Partition A"
}
node n2 as "Server 2" {
  database c2 as "Partition C"
  database b2 as "Partition B"
}
node n3 as "Server 3" {
  database c3 as "Partition C"
  database a3 as "Partition A"
}
n1 <-right-> n2
n2 <--> n3
n1 <--> n3

#+END_SRC

#+RESULTS:
[[file:graphics/partitioned-data-stores.png]]

*** Partitioned row stores
Each /row/ has a /key/ that specifies which partition(s) store data for that row. Data is typically stored in columns, following a schema.

- Open source: Cassandra
- Amazon: DynamoDB, Keyspaces
- Google: BigTable
- Azure: Cosmos DB (with Cassandra API)
*** Example cassandra queries
- Creating a table
#+BEGIN_SRC sql
CREATE TABLE chat_messages (
  roomId int,
  seqNr int,
  edited timestamp,
  userId int,
  message text,

  PRIMARY KEY (roomId, seqNr)
);
#+END_SRC
  + Table must have a primary key
  + Part of the primary key is the /partition/ key, which dictates how the data is partitioned (sharded)

- Inserting (or updating) rows
#+BEGIN_SRC sql
INSERT INTO chat_messages (roomId, seqNr, edited, userId, message)
  VALUES (1, 1, NOW(), 42, 'This is my message');
#+END_SRC
  + This will insert (or overwrite) the row for the data's primary key values
  + =UPDATE= also exists, and has the same semantics

- Did somebody say this is NoSQL?
*** Partitioned queues
Messages sent to a queue (sometimes called topic) are distributed to partitions, based on a /key/.
Messages typically small (some services have upper limit of 64kB).

- Open source: Kafka
- Amazon: SQS
- Google: Cloud Pub/Sub
- Azure: Storage Queue ( * ) , Service Bus ( * )

( * ) /not partitioned, size-limited/
*** Partitioned search
Full-text search is often important when dealing with data.

- Open source: Elasticsearch, SoLR
- Amazon: Hosted elasticsearch
- Google: Hosted elasticsearch
- Azure: Hosted elasticsearch
** Single-server data stores
*** Single-server data stores: introduction
- Many moving parts needed to make primary/replica failover work
  * PostgreSQL: Multiple servers possible, but failures leak to the client. =pgBouncer= as alternative.
  * MariaDB: Multiple servers possible with failover, fail-back is a manual process
  * RabbitMQ: Multiple servers possible with failover, but fail-back doesn't work in Spring ([[https://jira.spring.io/browse/AMQP-318][AMQP-318]])
- If you choose these, make failover testing part of your CI
*** PostgreSQL
- Relational database with a strong history of transactional correctness
- Very high performance
- Modern features
  + Native JSON support with indexes
  + Add indexes without locking tables
- Single-server, but flexible native replication options
  + Multiple read replicas
  + Subset-read replicas (/"logical replication"/)
- Database-level sharding software exists, but application-level sharding is recommended
*** RabbitMQ
- Message queue with focus on performance
- Original architecture single-server
  * Later extended with /Mirror Queues/ (primary/replica)
  * Extended with /Quorum Queues/ in 2019 (raft)
    + No message TTL, no message priorities
    + All cluster members have all data
    + All messages in memory! (in addition to storage)
*** RabbitMQ Data consistency
- AMQP "transaction"
  * Covers only a single queue
  * "Slow" (fsync for every transaction)
- /Publisher confirms/
  * Asynchronous message from RabbitMQ to client (after fsync): =basic.ack= or =basic.nack=
  * Impossible to predictably deal with lost broker connection (risk duplicate, risk lost messages)
- Manual /Consumer acknowledgement/
  * Consumer sends message to RabbitMQ to confirm handling of message is complete
  * =basic.ack=, =basic.nack(requeue)=, =basic.nack(no requeue)=
  * This is async, so no guarantee that the server receives it
    + Two generals agree
** Monitoring and alerting
*** Introduction
- Logging need not be a cross-cutting concern
  * Create monitored metrics instead
- Your service dashboard is as important as your public API
  * Have metrics on /everything/
  * Dashboard should be visible to and understandable by non-team members
- Be aware of your resource usage, check all environments at least daily
*** Protocol variations
- Push-based (=statsd=)
  * Application periodically (10 seconds) sends UDP packet(s) with metrics
  * Simple text-based wire format
  * Composes well if running with multiple metrics backends
  * Advantages: composability, easy to route, less moving parts
- Pull-based (prometheus)
  * Database calls into microservice periodically (10 seconds) over HTTP
  * Service needs to run extra HTTP server
  * Does not compose (multiple metrics backends need to be known on the prometheus side)
  * Advantages: less timing-sensitive
*** Metrics terminology
- Different frameworks use different terms
- [[https://micrometer.io/][Micrometer]] uses the following:
  * /Counter/ (sometimes called /event/): An occurrence of a discrete event
    + e.g. a request coming in
  * /Gauge/: The size of a single measurable quantity (and its unit)
    + e.g. the number of active TCP connections
  * /Timer/: The duration of an activity
    + e.g. the response time to a request
  * /Distribution summary/ (sometimes called /histogram/ or even /gauge/): Recorded values (and units) that go with events
    + e.g. the size of incoming requests in bytes
** Request tracing
*** Complex service dependencies
- Services can have complex calling stacks
[[file:graphics/svg/tsflow.png]]

- When something breaks, it's good to have a trace

- Other reasons
  * Identify performance problems
  * Find bottlenecks
  * Track resource usage
*** Two mature solutions
- [[https://www.jaegertracing.io/][Jaeger]] and [[https://zipkin.io/][Zipkin]]
  * Both have vast library and framework support
  * Many metrics framework support both backends
[[file:graphics/zipkin.png]]
** Deployment
*** Hosted, semi-hosted or self-hosted?
- Learning a new data store technology
  + Reliability guarantees
  + Scalability and performance characteristics
  + API
  + Installation and operation (for developers)
  + Installation and operation (in production)
- You can save on the last bullet, but not on the others

- Self-hosted
  + You install and run everything yourself
    * Kafka, Cassandra, Elasticsearch
    * Typically on Docker & Kubernetes
  + Can re-use knowledge and code between development and production
- Semi-hosted
  + Cloud provider installs and operates existing (typically open source) software for you
  + But you still have to pick server size and count
  + You're billed per server
- Hosted
  + Cloud provider installs and operates everything for you
  + You're billed per logical storage unit (e.g. database row or queue message)
*** Pets vs. cattle
- /Pets/: Traditional server management
  + Servers have cute names
  + Some server names I've seen: =pinkie=, =oink=, =tardis=, =deepthought=, =zeus=
  + Everyone know the peculiarities of each server

- /Cattle/: Cloud server management
  + Servers have only a logical ID or number
  + Hardware setup, rack and/or location
  + Find an available server to put your service on
*** Virtualization and containerization
- First, there was plain hardware
- VM abstraction
  * Decoupling of multiple roles of one server
  * Memory and disk overhead
  * Linux optimizations (kernel shared memory)
- Linux can do many of this natively
  * /Namespaces/: Hide processes from each other
  * /Cgroups/: Limit resource usage
- Containers to make it fast and efficient
  * VM: GBs
  * Docker (ubuntu): 100's of MB
  * Docker (alpine): MBs
  * Instant startup
*** Docker
- Limited to linux in this course
- Lightweight layer over native cgroups isolation

- Dockerfile
#+BEGIN_SRC dockerfile
FROM node:12-alpine
RUN apk add --no-cache python g++ make
WORKDIR /app
COPY . .
RUN yarn install --production
CMD ["node", "src/index.js"]
#+END_SRC
  * Layers
  * Volumes
    + Handling of persistent data
  * Port mapping

- User mapping
- Don't run as root
*** Docker-compose
#+BEGIN_SRC yaml
version: '3.1'

services:

  db:
    image: postgres:13.2-alpine
    # Uncomment this to have the DB come up when you start docker / your laptop:
    #restart: always
    environment:
      POSTGRES_USER: demo
      POSTGRES_DB: demo
      POSTGRES_PASSWORD: example
    ports:
      - 5432:5432

  rabbitmq:
    image: rabbitmq:3.8.16-alpine
    # Uncomment this to have the DB come up when you start docker / your laptop:
    #restart: always
    ports:
      - 5672:5672    # AMQP
      - 15672:15672  # Web UI
#+END_SRC

- Groups several docker containers and storage
- Ideal for local testing
*** Kubernetes
- Manages a cluster of distributed docker containers with copies
  * /Pod/: Combination of one or more docker containers and their configuration
  * /Configmap/: Extra settings for pods, typically becoming a volume in the pod
  * /Deployment/: Automatic replicas and distributed upgrades for pods (and other resources)
- Ideal for production
- Configure Memory requests and limits
- Configure CPU requests
- Get comfortable getting thread and heap dumps
- Heap dump on out of memory (this /will/ happen)
  * =-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/dumps= to an =emptyDir= volume
** Configuration
*** Handling of externalized values
- Externalize "magic numbers" and strings
- Embrace your framework's ability to have /internal/ and /external/ configuration
  * /Internal/ (inside docker container) has defaults and values that don't really change
  * /External/ (mounted as a volume) has settings specific for that environment and/or server
- Changes to configuration files
  * Kubernetes: Configmap change does /not/ restart the pod
  * Hot reloading? Not in spring boot (watch file and shutdown instead)
- Environment variables for secrets: don't do it (leaking to docker, monitoring tools)
  * use files instead
- Environment variables for service injection: don't do it (ordering issues)
  * use dns instead (e.g. dns-java, akka discovery, [...])
** Load balancer
*** Allowing the world to call your service
- Deployed kubernetes services only reachable within the cluster
- Need to define an =ingress=
  * HTTP-level ([[https://github.com/nginxinc/kubernetes-ingress][NGinx]]) or TCP-level ([[https://github.com/haproxytech/kubernetes-ingress][HAProxy]])
  * Provided by your native cloud provider
  * Hybrid setups
- Additional, external, load balancer in front of ingress controller
* Break(out) 2
** Infrastructure discovery
*** Introduction
- Resume in your teams
- Which pieces of infrastructure exist around the services you discovered?
- Who "owns" or maintains them?
- How can you set up new infrastructure?
- Look at all categories of infrastructure:
  + Servers
  + Data stores
  + Load balancers and gateways
  + Monitoring and dashboards
  + Others
*** Discussion
- Describe the infrastructure you have found
* Data architecture
** Domain-driven design
*** Introduction
- Software methodology
  * /Names in code must names used by the business/
- Popularized in 2003 by [[https://www.dddcommunity.org/book/evans_2003/][Eric Evans]] in his book
- Simple guideline lead to extremely useful patterns
*** Bounded context
- Reasoning about complex business processes requires abstractions
  * A /domain model/ implements these abstractions as code
- Abstractions, and hence models, have a limited applicability
- /Bounded context/ makes this explicit
  * When creating a domain model, evaluate the scope of your design
  * Create sub-domains when you encounter them
  * Describe the bounds for your domain

- Bounded context is often a good candidate for Microservice boundaries
*** Ubiquitous language
- We have a domain model, great!
- Added value comes from day-to-day conversations
  * Among developers
  * Between developers and the customer
  * Between developers and the user
- Is everyone speaking the same language?

- /Ubiqutous language/: All team members use important terms in the same way
  * Within a bounded context
*** Event storming workshop
- We need to quickly learn a new domain
  * /Business process modeling/ and /requirements gathering/
  * Bring together /domain experts/ and /developers/: Invite the right people!
  * Primary goal is a mutual understanding of the domain

- Alberto Brandolini (2012): [[https://www.eventstorming.com/book/][Event Storming]]

- Discover events that occur in the business, and what triggers them
  * *Business Event*, e.g. /a customer has applied for a loan/
    - A change has occurred (in your business or in the real world)
  * *Command*, e.g. /create a new loan request/
    - A request or interaction to be made with a system (ours or external)
    - Decided upon and initiated by a user, or by an external system
  * *Read model*, e.g. /customer account balance/
    - Information that a user or external system needs to base commands on
  * *Actor*, e.g. /loan requester/
    - Role of a person submitting a command
  * *Aggregate*, e.g. /Loan Application/
    - Entity(ies) of a business subdomain that should be viewed atomically

- Why do you think the focus is on /Events/, rather than /Aggregates/?
*** Event storming workshop (example)
- An small example of all concepts is [[https://excalidraw.com/#json=vxsHdxpc7576WIp-WA8TC,vWuOODe-XG1sA4K0NtGPnw][here]]
[[file:graphics/svg/event-storming-excalidraw.png]]
** Data design patterns
*** Idempotency
- Allow any failed or repeated action to be applied again
  + With the same result (if previously successful)
  + Without additional side effects that have business impact

- Example:
  + New user is stored in our database, but afterwards we failed sending their welcome mail (SMTP server was down).
    * Retry the database operation: User is already found, so instead we verify that the data matches
    * Retry sending the mail: We know that we didn't send the mail yet, so we send it once more
  + New user is stored, welcome mail is sent, but we failed updating our CRM system
    * Retry the database operation: User is already found, so instead we verify that the data matches
    * Retry sending the mail: We know that we've already sent this mail, so we simply do nothing
    * Retry updating the CRM system
*** Event Sourcing
- Traditional relational database: CRUD
  * Update in place
- Change log, shadow table

- Turn it upside down: /Event journal/ is the source of truth
  * Read from the event journal to create your query model
  * No more CRUD
  * Read from your event journal again: /full-text search!/
  * Read from your event journal again: /business analytics!/

- Event journal can even be a part of your API
*** Eventual consistency
- Traditional approach to consistency (/transactions/)
  + Data store hides concurrent modifications of multiple areas from each other, enforcing constraints
  + Modifications typically (hopefully) fail if attempting to modify the same data
  + Even within one data store, hard to get 100% right
  + Complexity skyrockets when trying to scale beyond one data store (/distributed transactions, XA/)

- Eventual consistency
  + Embrace the flow of data through the system hitting data stores at different times
  + Embrace real time as a parameter to affect business logic
    * /Is it OK if a document I just saved doesn't show in the list until 0.5 seconds later?/
  + Apply *Idempotency* to all data store updates
  + Leverage *Event Sourcing* where possible
*** Command query responsibility segregation
- CQRS: Have two separate data models (and split your API accordingly)
  * A /command/ model, for API calls that only change data (and do not return data)
  * A /query/ model, for API calls that only return data (and do not change data)

- Builds on CQS (Command query separation). One method can only do one of two things:
  * Perform a /command/, by having side effects (and not returning a value)
  * Perform a /query/, returning a value (and not having side effects)

- We'll see CQS again
** Data formats
*** XML
#+BEGIN_SRC xml
<?xml version="1.0" encoding="UTF-8"?>
<Invoice
 xmlns="urn:oasis:names:specification:ubl:schema:xsd:Invoice-2"
 xmlns:cac="urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2"
 xmlns:cbc="urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2">
 <cbc:ID>42</cbc:ID>
 <cbc:IssueDate>2004-05-24</cbc:IssueDate>
 <cac:InvoiceLine>...</cac:InvoiceLine>
 <cac:InvoiceLine>...</cac:InvoiceLine>
 <cac:InvoiceLine>...</cac:InvoiceLine>
 <cbc:ShoeSize/>
 <cac:LegalMonetaryTotal>
  <cbc:PayableAmount currencyID="USD">52.00</cbc:PayableAmount>
 </cac:LegalMonetaryTotal>
</Invoice>
#+END_SRC

- Extensible Markup Language
- Composes very well
  * Namespaces prevent shadowing
  * Natural order of tags can be useful
- /De facto/ schema standard (XSD) has unfortunate limitations
  * Hard to express "order does not matter"
  * Hard to express "this schema can be extended with extra tags and attributes"
  * Alternatives: /schematron/ (alive) and /relax-ng/ (dead?)
- Still, a very sensible default choice
*** JSON
#+BEGIN_SRC js
{
  "invoice": {
    "id": "42",
    "issueDate": "2004-05-24",
    "legalMonetaryTotal": {
      "payableAmount": {
        "value": "52.00"
        "currencyID": "USD"
      }
    }
  }
}
#+END_SRC
- /JavaScript Object Notation/
- Started its life in the web browser (~2000)
  * XML inconvenient to deal with in Javascript back then (SAX API)
  * JSON could just be parsed as Javascript directly
- No namespaces
  * JSON is useless without context
- No (useful) types
  * JavaScript /number/ is a technically a double-precision float (even though in JSON it can contain unlimited digits)
  * Even [[https://json-schema.org/understanding-json-schema/reference/numeric.html][JSON schema]] does not remedy this
- No comments
*** Protobuf
#+BEGIN_SRC js
message SearchRequest {
  required string query = 1;
  optional int32 page_number = 2;
  optional int32 result_per_page = 3;
}
#+END_SRC

- Very compact binary format
- Started at Google, today >70 implementations
- Built with organic versioning in mind
- Ideal for storing events of event sourcing (if you have a lot of them)
*** Designing for extensibility
- Use schemes and code lists instead of fixed enumerations
#+BEGIN_SRC xml
<InvoiceAmount currencyID="USD">42.00</InvoiceAmount>
#+END_SRC

- Use rich data objects instead of flat numeric values
  * e.g. =Amount=, =Measurement=, =GeoCoordinate=, =Quantity=

- Use namespaces and URIs where you can
* Break(out) 3
** Let's hold an event storming workshop
*** Domain scope
- Let's find a domain and scope for the events we want to discover
  + Is there a shared system, or domain, most of you have worked on?
  + Is there a shared system, or domain, most of you know is important for your business?
*** Alternative: Pet Shop
(skip if domain is found)

- Let's model a pet shop!
  + Our family owns a pet shop, which has a building that houses pets for sale
  + We regularly sell pets, and re-stock
  + Pets need to be fed
  + Some pets have special other needs
  + We only want to house cute pets!

- We want to automate as much as we can, and hence hold an event storming workshop
** Event storming stages
*** Big picture
- Distribute orange post-its

- Remember, an event is in PAST TENSE, e.g.:
   /Missiles have been launched/
   /User has subscribed to newsletter/

- Designate a wall as space
  + Create time marker. Time flows roughly from left to right (where relevant)

- Start with "pivot" event in center

- Write other events that come to mind
  + Order with existing events, keeping time
  + Feel free to rename as discussions occur
*** Big picture: Need more?
- Full narrative (1 person)
- Reverse narrative
*** Pivotal events and boundaries
- /Pivotal event/ is an event that is of particular business importance (and value)
  + Spawns new business processes
  + Involves new stakeholders
  + Commits the business to a financial risk or responsibility
  + Confirms the business receiving a financial benefit

- Can we, along pivotal events, distinguish /Bounded Contexts/ in our events?

*** Process modeling
- Distribute blue, yellow, green and pink post-its
  + Blue: /command/
  + Yellow (small): /actor (persona)/
  + Pink: /external system, department, time/
  + Green: /read model/

- Remember, a command is in IMPERATIVE, e.g.
  /Launch missiles/
  /Register user subscription request/

- Consider limiting scope to a part of what we modeled as Big Picture

- Select important events, that related to something a system could do for us
  + What command could cause this event? (blue)
  + Who or what can trigger this command?
    * Who: Actor (yellow)
    * What: External system (pink)
  + What information is needed to construct the command (green)

*** Aggregates
- What nouns have we discovered that are good candidates for aggregates?
  + Yellow (large): /aggregate/
  + Group the commands by aggregate

- What aggregates would be good candidates for microservices?
* Wrapping up today
** Let's do another round
*** Please share!
- Name one thing that you learned
- Name one thing that you knew already
- Name one thing that surprised you
* Start of day 2
** Getting started
*** Schedule, Day 2
|  Time | Duration | Activity                                  | Weight |
|-------+----------+-------------------------------------------+--------|
| 09:00 |    00:10 | Welcome, Outline/Agenda                   |        |
| 09:10 |    00:10 | Recap of day 1                            |        |
|-------+----------+-------------------------------------------+--------|
| 09:20 |    00:20 | Getting your service used                 |        |
| 09:40 |    00:40 | An introduction to REST                   |        |
|-------+----------+-------------------------------------------+--------|
| 10:20 |    00:30 | (Break)out 4                              |        |
|-------+----------+-------------------------------------------+--------|
| 10:50 |    00:20 | Discussion of breakout results            |        |
| 11:10 |    00:60 | REST patterns                             |        |
| 12:10 |    00:30 | Lunch                                     |        |
|-------+----------+-------------------------------------------+--------|
| 12:40 |    00:10 | REST API examples                         |        |
|-------+----------+-------------------------------------------+--------|
| 12:50 |    00:30 | (Break)out 5                              |        |
|-------+----------+-------------------------------------------+--------|
| 13:20 |    00:15 | Discussions of breakout results           |        |
| 13:35 |    00:20 | Microservice life cycle                   |        |
| 13:55 |    00:10 | Security architecture                     |        |
| 14:05 |    00:15 | Strategy and team dynamics                |        |
| 14:20 |    00:30 | Group exercise (adoption)                 |        |
|-------+----------+-------------------------------------------+--------|
| 14:50 |    00:30 | (Break)out 6                              |        |
|-------+----------+-------------------------------------------+--------|
| 15:20 |    00:30 | Presentations of breakout results         |        |
| 15:50 |    00:10 | Wrap-up, reserved time for extra subjects |        |
#+TBLFM: @3$1..@>$1=@-1$2+@-1$1;U
*** Recap of day 1

Who can tell us something about:

[[file:graphics/svg/wordcloud-services.png]]
* Getting your service used
** Public API
*** An API is an interface
- /Application Programming Interface/
  * It's how external components affect what our service does
  * Better lay down some rules
- But our service is only used by our team, we don't need documentation!
- Ideal for test-first development
- Where do I put my private API?
*** Example API
- Let's look at an [[file:demo-project/documentation/demo-api.html][example API]] example API together
  * Its [[file:demo-project/documentation/demo-api.raml][RAML source]] is available
- Semantic format for describing REST APIs: RAML, OpenAPI
  * RAML: YAML-based, better re-use, easier to write by hand
  * OpenAPI: JSON/YAML-based, more popular
*** Content-type negotiation
- Embrace content-type negotiation (XML /and/ JSON, not XML /or/ JSON)
- XML API:
  * Do create XSD for your data types, but communicate how it should be interpreted
  * Do you reserve the right to add new tags and attributes?
- JSON API:
  * Create JSON schemas for everything
  * In addition, verbosely describe all numeric types and their intended usage

** Public developer guide
*** But I've written the documentation!
- Just a list of endpoints may not be enough for some developers
- Lot of context and assumed knowledge
  * Ubiquitous language may not extend to all new API users
  * Lack of experience with JSON, XML, HTTP headers
*** Different people, different learning styles
- Write a developer guide that describes typical scenarios from a user's perspective
  * How to get started (e.g. get an SSL certificate)
  * How to list widgets in XML or JSON
  * How to create a new widget
- There's no shame in taking an English technical writing course
- Pick tooling that suits your way of working (e.g. =HTTPie=, =org-mode= with =org-babel=, ...)
** Public service dashboard
*** Priorities!
- What's the first thing you do when you get to your office?

- Users will be curious about your service status
  * If your users are internal, give them access to the actual dashboard
  * In fact, consider giving them access to your source code and issue tracker as well
*** Designing your dashboard
- Your dashboard should be showing
  * System metrics (load average, disk space, CPU usage, memory usage, network I/O, disk I/O)
  * Your process' metrics (CPU usage, memory usage)
  * Your VM's metrics (Heap committed, heap used, GC time, thread count, log count)
  * Your framework's metrics (HTTP server open connections, HTTP client open connections, response times, response errors)
  * Your business metrics (number of pets signed up, total invoice amount, size of received chat messages)

- For each environment, after a few days examine the graphs
  * Establish a baseline, and create an alert for /each/ metric
* An introduction to REST
** REST philosophy
- *World-wide web* (1990): HTTP over internet, with hypermedia (HTTP)
  + Unprecedented scaling
  + Applications (e.g. Facebook, Amazon) can develop continuously without clients (browsers) breaking
    * /(at least, until they figured out native clients means no ad-blockers...)/
  + Managed to survive 20+ years in a wild changing landscape, with limited technical debt
    * Most of HTTP and HTML are still relevant
- Apparently, it's possible to perform heterogeneous systems integration without any
  + legal contracts,
  + deep specifications, or
  + personal knowledge

- Try pulling that off in your enterprise!
** REST principles
- Apply the WWW success for system-to-system communication
  + =RE= presentational =S= tate =T= ransfer
- Request-based from /client/ to /server/
  + Distinctly separated roles that two systems or actors play when handling a request
- Stateless
  + Request contains all information needed to process it (instead of, e.g. the TCP connection socket)
- Caching
  + Responses must clearly state, and have sensible defaults, on how content can be cached
- Uniform interface
  + All components are accessed the same way
- Layered system
  + Intermediaries can be transparently inserted between client and server (load balancers, proxies, security gateways, ...)
** Resources
In REST, the /client/ accesses a /resource/ on the /server/, through a /request/.

A resource:
- Is a noun, e.g. /user/, /invoice/, /setting/, but also /transaction/, /order status/, or /deletion process/
- Can have several representations, e.g. XML, JSON, HTML, picture, small, large
- Is accessed through one or several URLs
  + =/users/15=, =/users/latest=, =/users?name=Santa= might all return the same resource
- Is interacted with through a limited set of verbs (more on that later)

Remember your event storming workshop?
** An introduction to HTTP
- Text-based protocol over TCP
  + Client sends a request (with /verb/, /headers/, and optional /body/)
  + Server sends a response (with /status line/, /headers/, and optional /body/)
  + (since HTTP 1.1) Client sends a new request, etc.

Client sends:
#+BEGIN_SRC restclient
GET /cats/latest?fur=white&size=small
Accept: image/png
User-Agent: Mozilla/5.0

#+END_SRC

Response then comes in:
#+BEGIN_SRC restclient
200 OK
Content-Type: image/png
Content-Length: 53748

[...kitten goes here...]
#+END_SRC
*** HTTP Verbs
- Predefined verbs imply important caching and retry semantics
|--------+----------------+-------------+---------------+----------------+-----------------|
| Verb   | Safe to retry? | Idempotent? | Request body? | Response body? | Cache response? |
|--------+----------------+-------------+---------------+----------------+-----------------|
| GET    | yes            | yes         | -             | yes            | yes             |
| HEAD   | yes            | yes         | -             | -              | yes             |
| PUT    | -              | yes         | yes           | -              | -               |
| POST   | -              | -           | sometimes     | sometimes      | -               |
| DELETE | -              | yes         | -             | -              | -               |
|--------+----------------+-------------+---------------+----------------+-----------------|

- Why wouldn't =PUT= or =DELETE= be safe to retry?

- Rest is not RPC
*** Example HTTP status codes
The /status line/ contains a code and then a short description. The description is not predescribed, and sometimes contains useful information.
- =200 OK=
  + The request succeeded. Typically a response body is present.
- =201 Created=
  + The request succeeded, and a new resource was created as a result.
- =204 No Content=
  + The request succeeded, but no content is available.
- =302 Found=
  + The resource was found at a different URL, which is returned in the =Location= header.
- =404 Not Found=
  + The resource does not exist. This does /not/ necessarily mean that an API endpoint does not exist.

This is not a full list. See the HTTP [[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes][official status codes]] or a more [[https://http.cat/401][graphically-accessible variant]].

*** Example HTTP Headers
- =Accept: image/*=
  + Sent in a /request/ to indicate the MIME types that the client prefers for this request (but there's no guarantee)
- =Content-type: image/png=
  + Sent in a /request/ or /response/ to indicate the actual MIME type of the body
- =Content-length: 5124=
  + Sent in a /request/ or /response/ to indicate the size of the body in bytes (if known)
- =Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT=
  + Sent in a /response/ to indicate when that resource was last changed

This is not a full list.
** REST API design
- Find resources for your domain
  + Perhaps using an /Event Storming/ workshop (from /Domain-Driven Design/)
- Use CQRS (Command Query Response Segregation)
  + Find representations for those resources (current state and/or events): =GET=
  + Find commands affecting those resources (creation, modification, transactions): =POST=, =PUT=, =PATCH=, =DELETE=
- Size limits on everything (do we need to stream or read it in memory?)
- XML, JSON, CSV, text, protobuf (more content-type negotiation later)
- Decide on a /Service Level Objective/ for your API (yes, already now)
* Break(out) 4
** Finding REST services
*** Assignment
- Divide into teams

- Find documentation of a REST web service
  + Preferably: Internally published in your company
  + Otherwise: Publicly on the internet, examples: /e-conomic/, /twitter/, /github/, /AWS/, /flickr/

- Create a full example request
  + Request headers and (if relevant) body
  + Response status line, headers, and (if relevant) body
  + Bonus points if you can actually execute the request!

*** Presentation of results
- Show us the services you found

- How did you find the quality of documentation?
* A selection of REST patterns
** Resource tags and caching
*** Resources have versions
- Servers can include an =ETag=, which specifies which /version/ of a resource is being served
#+BEGIN_SRC restclient
GET http://example.com/widgets/15

200 OK
Content-Type: application/json
ETag: "524"
#+END_SRC
- No guarantees are made about the content of =ETag=, but often APIs will document what it represents, e.g.
  * A timestamp of some sort
  * A monotonically-increasing number
  * A hash of the latest content
*** Conditionally retrieving a resource
- If the latest =ETag= we have seen is "524", we can poll for changes
- The =If-None-Match= header will /only/ execute our request if the =ETag= has changed
#+BEGIN_SRC restclient
GET http://example.com/widgets/15
If-None-Match: 524

304 Not Modified
#+END_SRC
- The server will not send any response if the resource is still at this version
*** Optimistic offline lock
- The =ETag= is also useful to make sure nobody else has edited a resource that we're writing back
- The =If-Match= header will /only/ execute our request if the =ETag= matches
#+BEGIN_SRC restclient
PUT http://example.com/widgets/15
If-Match: 12345
Content-Type: application/json

{ /* ... some content ..* }

412 Precondition Failed
#+END_SRC
*** Resources can be modified
- Servers can include a =Last-Modified= tag, which specifies /when/ a resource was last changed
- This can be useful in addition to an =ETag= tag
#+BEGIN_SRC restclient
GET http://example.com/widgets/15

200 OK
Content-Type: application/json
ETag: "524"
Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
#+END_SRC
- Request header exist that perform checks against the last-modified date, like =ETag=:
  * =If-Modified-Since= executes the request /only/ if the last-modified is past the given date
  * =If-Unmodified-Since= executes the request /only/ if the last-modified is at most the given date
*** Preventing caching
- For service-to-service REST calls, we generally don't worry about caching
- For web browsers, we often want to disallow caching of REST responses
  * Include =Cache-Control: no-cache=
** Content-type negotiation
*** Resource representation
- The same REST URI is allowed to have several representations
  * XML, JSON or Protobuf
  * Short or long
  * Version 1 or version 2
*** Specifying resource representation
- The server specifies the representation of a resource
  * The =Content-Type= resource header
- This is typically a well-known value
  * =text/xml=
  * =application/json=
  * =application/protobuf=
- But it doesn't have to be
  * =application/vnd.example.myresource.v1+json=
  * =application/vnd.example.myresource.v2+json=
  * =application/vnd.example.myresource.short+json=
  * =application/vnd.example.myresource.long+json=
*** Requesting a resource type
- The client sends an =Accept= header with the representations it wants/understands
- In case of a single representation:
#+BEGIN_SRC restclient
GET http://localhost/myresource
Accept: application/json
#+END_SRC
- In case multiple representations are alright (order has no semantic meaning):
#+BEGIN_SRC restclient
GET http://localhost/myresource
Accept: application/json, text/xml
#+END_SRC
- Multiple representations are alright, but preference for xml:
#+BEGIN_SRC restclient
GET http://localhost/myresource
Accept: application/json;q=0.9, text/xml
#+END_SRC
*** Serving resource alternatives
- Content-type negotiation is complex to implement
- How easy it is to support depends on your framework
  * /Spring Boot/ has many different ways to manage resource representation
    + Look into =HttpMessageConverter=, so you can take control
  * Others, e.g. =akka-http= has a marshaling infrastructure that directly models content-type negotiation
** Asynchronous and long-running processes
*** Case: REST API to represent workflow instances
- Start a new workflow
- See which human is working on the case
- Quickly resume if system is working on the case
*** REST is about resources
- For slow-running processes, make the process itself a resource, e.g.
  * =/workflows/=
  * =/transactions/=
  * =/cases/=
- You can now reason about individual processes
  * Query state, affect them, delete them, see changes
*** Observing change on one resource
- Tell client to periodically poll
  * Use =If-None-Match= for early exit
  * Use heavy caching on the server-side to reply to polls as early as possible
*** Observing change on a set of resources
- Build your system using /Event Sourcing/
- Expose your event journal (or a light, or filtered version) as a REST resource
  * This can be done regardless of storage (JDBC, Cassandra, Kafka)
- Various candidates for the data format
  * Plain
#+BEGIN_SRC restclient
GET http://localhost/journal/events?since=Wed+May+26+11:59:05+2021+UTC&limit=50
Accept: application/json
#+END_SRC
  * Hanging GET
#+BEGIN_SRC restclient
GET http://localhost/journal/events?since=Wed+May+26+11:59:05+2021+UTC&limit=50&maxwait=60000
Accept: application/json
#+END_SRC
  * Server-sent events ([[https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events][SSE]])
#+BEGIN_SRC restclient
GET http://localhost/journal/events?since=Wed+May+26+11:59:05+2021+UTC
Accept: text/event-stream
#+END_SRC
  * Web sockets
#+BEGIN_SRC restclient
GET http://localhost/journal/events?since=Wed+May+26+11:59:05+2021+UTC
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13

HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
#+END_SRC
** Multi-dimensional versioning
*** Semantic versioning in REST
- Often used for library dependencies and packaged software releases
- Version number has three parts (/major/, /minor/, /patch/): version =2.0.15=
  * A new release always must have a new version
  * If a release has no new functionality (only bugfixes), increase the /patch/
  * If a release has new functionality that doesn't break API promises, increase the /minor/
  * If a release has new breaking functionality, increase the /major/
- How does this relate to REST?
*** Semantic versioning in REST (cont.)
- How does this relate to REST?
  * It doesn't!
  * REST is a call to a remote system
    + Could be deploying new versions multiple times per day
  * The whole point is the client /doesn't/ want (or need) to see those

- OK, what do we do instead?
  * Version across all HTTP dimensions
*** Versioning in body structure
- Many extensions fit fine into existing body structure
  * Adding of fields
  * Adding of values to enumerations or code lists
- If DDD has done its work, terminology should mostly hold
*** Versioning in content type
- If a breaking change is needed
- It might be limited to only one content type
- Client requests old version:
#+BEGIN_SRC restclient
GET http://localhost/myresource
Accept: application/vnd.example.myresource.v1+json
#+END_SRC
- Client requests new version:
#+BEGIN_SRC restclient
GET http://localhost/myresource
Accept: application/vnd.example.myresource.v2+json
#+END_SRC
*** Versioning in query parameters
- Don't do this
  * Query parameters affect /which/ and /what/ resource(s) are returned, not /how/
- The meaning of query parameters may themselves be versioned
*** Versioning in path
#+BEGIN_SRC restclient
GET http://localhost/service/versions/1/myresource
#+END_SRC
- Often used as first choice
- Should be your last resort:
  * Your path is the name of your resource
  * Your DDD workshop (probably) didn't event storm about "versions"
  * Your system (probably) doesn't have 2 complete implementations
  * This does often not reflect reality
*** Versioning using custom headers
- Client sends a custom header of the API version they've implemented against
- Server sends a custom header of the API version that's current
- This does kinda work

- Fairly weak way to work around /actually/ dealing with semantic changes and compatibility
* REST API Examples
** Examples of REST design
*** Github
#+BEGIN_SRC restclient
GET https://api.github.com/search/issues?q=windows+label:bug+language:python+state:open&sort=created&order=asc
Accept: application/vnd.github.text-match+json

200 OK
Content-Type: application/vnd.github.text-match+json
{
  "text_matches": [
    {
      "object_url": "https://api.github.com/repositories/215335/issues/132",
      "object_type": "Issue",
      "property": "body",
      "fragment": "comprehensive windows [...] ter.\n",
      "matches": [ ... ]
    }, [...]
  ]
}
#+END_SRC

*** Github: Search for issues
Notes:

- Using a custom content-type to indicate a special flavor of JSON
- Relying on =GET= to indicate a read request
*** AWS
#+BEGIN_SRC restclient
GET https://ec2.amazonaws.com/?Action=RunInstances&ImageId=ami-2bb65342&MaxCount=3&MinCount=1&Placement.AvailabilityZone=us-east-1a&Monitoring.Enabled=true&Version=2016-11-15&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIDEXAMPLE%2F20130813%2Fus-east-1%2Fec2%2Faws4_request&X-Amz-Date=20130813T150206Z&X-Amz-SignedHeaders=content-type%3Bhost%3Bx-amz-date&X-Amz-Signature=525d1a96c69b5549dd78dbbec8efe264102288b83ba87b7d58d4b76b71f59fd2

200 OK
[... lots of json ...]
#+END_SRC

*** AWS: Create EC2 instance
Notes:

- a =GET= verb is used to have side effects!
- No resource representation of the actual server to be created
- Proprietary authentication mechanism, and using the URL for this

*** Flickr
#+BEGIN_SRC restclient
GET http://api.flickr.com/services/rest/?method=flickr.photos.search&api_key=xxx&text=trysil&format=rest&auth_token=xxx&api_sig=xxx
Accept: text/xml

200 OK
Content-Type: text/xml

<?xml version="1.0" encoding="utf-8" ?>
<rsp stat="ok">
    <photos page="1" pages="121" perpage="100" total="12050">
        <photo id="12185296515" owner="110367434@N02" secret="7bf83bc507" server="3714" farm="4" title="#wall #clock #wood #old #Norway #Trysil #travel #travelling" ispublic="1" isfriend="0" isfamily="0" />
        <photo id="12185880206" owner="110367434@N02" secret="c8042c1764" server="7382" farm="8" title="Good morning!   #Norway #Trysil #window #snow #beautiful #landscape #travel #travelling #polar #expedition" ispublic="1" isfriend="0" isfamily="0" />
        ...
        <photo id="11793639173" owner="40644602@N08" secret="ba2bdabf5c" server="7451" farm="8" title="by beateorten http://ift.tt/1dHDdQL" ispublic="1" isfriend="0" isfamily="0" />
    </photos>
</rsp>
#+END_SRC
*** Flickr's image search
Notes:

- Overloading of methods in the request URL
- Overloading of content type in the request URL
- Overloading of HTTP status code in the response
- No obvious way to explore the API further (how do I load a photo?)

* Break(out) 5
** Designing an API
*** Write a RAML or OpenAPI description for a pet store API
- We're writing a pet store automation system, and need to be able to register, find, and sell pets.

- We need APIs to:
  * Register a newly purchased pet
  * Register the feeding of pets
  * Search pets according to customer preferences
  * Register the sale of a pet

- RAML
  + example: https://raml.org/developers/raml-200-tutorial
  + spec: https://github.com/raml-org/raml-spec/blob/master/versions/raml-10/raml-10.md
  + online editor: https://raml-org.github.io/playground/learn_raml.html
- OpenAPI
  + spec: https://spec.openapis.org/oas/latest.htmla
  + online editor: https://editor.swagger.io/
*** Discussion
- One team makes their RAML or OpenAPI file available
- /Another/ team then tell us how to:
  * Register a newly purchased pet
  * Register the feeding of pets
  * Search pets according to customer preferences
  * Register the sale of a pet

* Micro service life cycle
** Dependency management
*** Developing a new service
- I want to write a new micro service!
  * I need a database, a queue, the filesystem for some caching
  * Oh, and I'm talking to twitters API, and our home-grown analytics API

- How do I deal with these dependencies during day-to-day development?
  * "Leaf" dependencies: often OK to run directly (e.g. data stores)
  * "Node" dependencies (other microservices): often have dependencies of their own
    + You know its API, right?
    + Mock it! Wiremock, or any simple http server

*** Running dependencies
  * Maintain a =docker-compose= file for your project
    + Real dependencies: they're probably on =docker-hub= already
    + Mocks: use the =build= feature if needed
  * New developers can get started instantly

** Extending a service
*** Developing a new feature
- Don't hide your new feature on a branch
- Release early and often
  * But only activate it in certain environments and/or users
- Feature flag
- A/B testing
** Testing
*** Unit tests OK, Integration tests not
[[file:graphics/tests.mp4]]
*** Introducing bugs
- Rate of bugs introduced into systems are a function of
  * Developer experience
  * Development environment (physical and technological)
  * Methodology

*** Finding bugs
- Fixing bugs is more expensive, the later they are found
  * While writing code: just think of different solution
  * While code is in review: communication, context switch, and the above
  * While code is in user testing: (much) more communication, context switch, and all the above
  * After code is released: (even) more communication, impact analysis in data, and all the above

*** Preventing bugs
- Test at different layers
  * On code itself: Pair programming
  * On one unit (e.g. class): /Unit tests/. Run in seconds.
  * On one service (e.g. rest API): /Component tests/. Run in tens of seconds.
  * On a suite of services (e.g. UI): /End-to-end tests/. Run in minutes.
  * On your entire infrastructure: /Smoke tests/. Run periodically, on production, with external dependencies
** Deployment
*** Getting your service out there
    "/All software has a test environment. Some software is lucky to have a separate production environment as well."/
        - unknown
*** Doing deployments
- Automate the environments themselves (=terraform=, =vagrant=, ...)
- All deployments to all environments must be automated
- It's OK to have gatekeepers, e.g.
  * After a PR is merged, automatic deploys are done to =dev= and =test= environments
  * The =prod= environment requires a manual button press
- Forward deploy only
  * Rollbacks are a pain
  * Your next deploy is only minutes away
  * Emergencies should be rare (testing, early release, multiple environments)
* Security architecture
** Authentication patterns
*** User-to-service authentication
- I want code running on a user's computer to call me (let's assume web browser)
- OpenID Connect, simplified flow:
  1. /Resource owner/ wants /client/ to log on to /authorization server/
  2. Client is redirected to authorization server
  3. User verifies trust of authorization server and logs on
  4. Authorization server redirects client back (with authorization code)
  5. Client contacts resource owner with /code/
  6. Resource owner exchanges code for /token/
  7. Token can be used in =Authorization: Bearer= http header

#+BEGIN_SRC plantuml :file openid.png :hidden
skinparam dpi :dpi
skinparam monochrome reverse
' partition "name" for sequence diagrams
title OAuth basic flow with auth code and access token

actor "You/Browser" as b
participant "slack.com" as s
participant "account.google.com" as a
participant "drive.google.com" as d

b -> s: 1. I would like to access my files on Google Drive via your interface.
s -> b: 2. You should apply the "Authorization Code" from Google for me first.
b -> a: 3. I would like to permit slack.com to access my files.
a -> b: 4. Are you sure?
b -> a: 5. [Y]
a -> b: 6. Okay. Here is the "Authorization Code." you can hand back to slack.com.
b -> s: 7. You can do what I asked now \n(with the Authorization Code which is just received from Google.)
s -> a: 8. I would like to exchange the "Authorization Code" for the "Access Token."
a -> s: 9. Your Access Token here.
s -> d: 10. I would like to read files which belong to one of my customers. Here is the Access Token.
d -> s: 11. Hmmm...the Access Token is vaild. Here is list of files you asked.
s -> b: 12. Grant succeed. You can see your files stored in Google Drive!
#+END_SRC

#+RESULTS:
[[file:openid.png]]


*** Service-to-service authentication
- I want code running on other backend services to call me (outside of the context of a user)

- Mutual TLS
  * Server has a certificate, proving it's who it claims
    + Client has established trust on a root certificate, having signed the server certificate
  * Client has a certificate, proving it's who it claims
    + Server has established trust on a root certificate, having signed the client certificate

- In practice
  * Create (or purchase) a root certificate for your business, lock it tight
  * Create intermediate CAs for particular roles, e.g. for singing micro-services
  * Use /Certificate Signing Requests/ to reflect real business flow
  * For your service clients
    + Have server sign client certificates directly
    + Or, delegate to an intermediate CA, and implement whitelisting
- Confirm that OCSP (/Online Certificate Status Protocol/) can be used to revoke certificates
** Implementation
*** Authorization checks
- Prefer to keep internal to service
- Replicate user memberships through event sourcing
- Synchronous calls least favorable choice
* Strategy and team dynamics
** Succeeding with microservices
*** Microservices and agile
- Embrace change
- Team visibility
- Stakeholder support
- Team(s) in same time zone as stakeholders (which includes users)
  * Distributed users? distributed team!
- Conway's Law
*** Migrating your monolith
- Chainsaw anti-pattern
- Strangler pattern
- Modules
*** Do we need a separate dev/ops team? (no)
- Automate everything (rolling production deploy)
- Deploy in the morning, monitor your dashboards
- However, "infra tooling" or "platform" team can be helpful
- The same holds for the "DBA" team
** Group exercise
*** Microservice adoption brainstorm
- Distribute post-its

- Write one post-it for:
    /In my daily work, I expect THIS to be most helpful in writing microservices/

- Write one post-it for:
    /In my daily work, I expect THIS to be the biggest blocker for writing microservices/

*** Gather results
- Two white board sections
  + /Drivers/
  + /Challenges/

- Put up your post-it, read aloud, and explain
*** Discussion

- Are there patterns to the drivers and challenges?
- What can we do to retain and strengthen the drivers?
- What can we do to remove the challenges?
* Break(out) 6
** Finding microservice candidates
*** Brainstorm
- Are there monoliths or other systems related to you or your team, that could benefit from microservices?

- Lets create a list of /large/ systems that you know of:
|-------------+-----------------+---------------|
| System name | Developer count | Lines of code |
|-------------+-----------------+---------------|
|             |                 |               |
|-------------+-----------------+---------------|

- Hint: Lines of code
  =git ls-files | xargs wc -l=

- Hint: Developer count
  =git shortlog -s -n --all=

*** Strategy
- Which of these systems have changes planned in the next year?
- Which of these systems have frequent bugs?
- Which of these systems do developers hesitate to make big changes to?

|-------------+------------|
| System name | Activities |
|-------------+------------|
|             |            |
|-------------+------------|

*** Design
- Divide into teams

- Pick one system and activity, and design a microservice that implements part of that domain
  + What surrounding data stores do you need to create?
  + How do the existing system and the microservice talk to each other?
  + Who maintains the existing system and microservice going forward?

* Interesting links
https://world.hey.com/joaoqalves/disasters-i-ve-seen-in-a-microservices-world-a9137a51
https://copyconstruct.medium.com/testing-in-production-the-safe-way-18ca102d0ef1

* Notes
** DDD
- Check room for best event storming wall
- Check room for (re)moving tables

** Other

- Add rabbitMQ stream example
- Pure function example (split up business logic and side effects)
- Screen sharing of others??

- Draw the UML diagram from https://developer.okta.com/blog/2019/08/22/okta-authjs-pkce
- Add HTTP cats https://http.cat/401
- Add comics
